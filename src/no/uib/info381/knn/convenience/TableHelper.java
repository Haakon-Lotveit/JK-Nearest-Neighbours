package no.uib.info381.knn.convenience;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;

import com.csvreader.CsvReader;


public final class TableHelper {
	
	/***
	 * default reading is unlimited records, shortcut method
	 * @param filePath
	 * @return
	 */
	public static Table ReadTableFromCSV(String filePath) {
		return ReadTableFromCSV(filePath, -1);
	}
	
	/***
	 * read data from csv file and store in table structure
	 * @param filePath
	 * @return
	 */
	public static Table ReadTableFromCSV(String filePath,int maxRecords) {
		Table table = null;
		System.out.println("Reading "+filePath+" and importing as table...");
		try {
			CsvReader dataset = new CsvReader(filePath);
			dataset.readHeaders();
			String[] Attributes = dataset.getHeaders();
			table = new Table(Attributes);
			
			String[] data = new String[Attributes.length];
			int records = 0;
			while (dataset.readRecord() && (records<maxRecords || maxRecords==-1))
			{
				for (int i=0; i<Attributes.length; i++)
					data[i] = dataset.get(Attributes[i]).trim();
				table.Insert(data);
				records++;
			}
			dataset.close();
			System.out.println("Successfully imported "+records+" records.");
			
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		return table;
	}
	
	/***
	 * Split an attribute by the values from another TargetAttribute in a table
	 * @param Attribute
	 * @param TargetAttribute
	 * @return returns a treemap of arrayslist of integers, where each array are the indexes of attribute generated by distinct values from TargetAttribute
	 */
	public static TreeMap<String,ArrayList<Integer>> SplitAttribute(Table table, String attribute) {
		int attrSize = table.RowSize();
		int attrIndex = table.GetAttributeIndex(attribute);
		if (attrIndex==-1) return null;

		// treemap contains subsets of Attribute splitted by TargetAttribute
		TreeMap<String,ArrayList<Integer>> attributeIndexes= new TreeMap<String,ArrayList<Integer>>();
		
		for (int row=0; row<attrSize; row++) {
			String SplitValue = table.GetCellContent(attrIndex, row);
			// initial construction of subset for given spit value
			if (!attributeIndexes.containsKey(SplitValue)) {
				ArrayList<Integer> indexes = new ArrayList<Integer>();
				indexes.add(row);
				attributeIndexes.put(SplitValue, indexes);
			// add more values to the subset
			} else {
				ArrayList<Integer> indexes = attributeIndexes.get(SplitValue);
				indexes.add(row);
			}
		}
		
		return attributeIndexes;
	}
	
	public static TreeMap<String,Integer> CountOccurences(Table table, String attribute)
	{
		int attrSize = table.RowSize();
		int attrIndex = table.GetAttributeIndex(attribute);

		// count occurrences of different values in Attribute
		TreeMap<String,Integer> ValueCounts = new TreeMap<String,Integer>();
		for (int row=0; row<attrSize; row++) {
			String Value = table.GetCellContent(attrIndex, row);
			if (!ValueCounts.containsKey(Value)) {
				ValueCounts.put(Value, 1);
			} else {
				int count = ValueCounts.get(Value);
				ValueCounts.put(Value, ++count);
			}
		}
		return ValueCounts;
	}
	
	/**
	 * converts list of Integer objects to int[]
	 * @param integers
	 * @return
	 */
	public static int[] convertIntegers(List<Integer> integers)
	{
	    int[] ret = new int[integers.size()];
	    for (int i=0; i < ret.length; i++)
	    {
	        ret[i] = integers.get(i).intValue();
	    }
	    return ret;
	}
}
